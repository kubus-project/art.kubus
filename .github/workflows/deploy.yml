name: Deploy

on:
  push:
    branches:
      - master
      - main
  workflow_dispatch:
    inputs:
      deploy_web:
        description: 'Deploy Flutter web build to app server via FTP'
        required: false
        default: true
        type: boolean
      build_apk:
        description: 'Build Android APK (debug-signed release mode)'
        required: false
        default: true
        type: boolean
      publish_github_release:
        description: 'Create/Update a GitHub Release and upload the APK'
        required: false
        default: true
        type: boolean
      release_tag:
        description: 'Release tag to create/use (leave empty to auto-generate)'
        required: false
        default: ''
        type: string
      prerelease:
        description: 'Mark GitHub Release as a prerelease'
        required: false
        default: true
        type: boolean

permissions:
  contents: write

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy_web:
    name: FTP deploy (Flutter web)
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.deploy_web) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: false

      - name: Check FTP secrets
        id: ftp
        shell: bash
        env:
          FTP_SERVER: ${{ secrets.FTP_SERVER }}
          FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
        run: |
          if [ -n "$FTP_SERVER" ] && [ -n "$FTP_USERNAME" ] && [ -n "$FTP_PASSWORD" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "ok=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Normalize FTP server host/port
        if: ${{ steps.ftp.outputs.ok == 'true' }}
        id: ftp_target
        shell: bash
        env:
          FTP_SERVER_RAW: ${{ secrets.FTP_SERVER }}
          FTP_PORT_RAW: ${{ vars.FTP_PORT }}
        run: |
          # Users sometimes put values like:
          #   ftps://ftp.example.com
          #   ftp.example.com/
          #   ftp.example.com:21
          # This step normalizes to HOST + PORT without printing the secret value.

          RAW="${FTP_SERVER_RAW}"
          RAW="$(printf '%s' "$RAW" | tr -d '\r\n')"
          RAW="$(printf '%s' "$RAW" | xargs)"

          HAS_PROTO=false
          if [[ "$RAW" == *"://"* ]]; then
            HAS_PROTO=true
          fi

          HOSTPORT="$(printf '%s' "$RAW" | sed -E 's#^[a-zA-Z]+://##; s#/.*$##')"
          HOSTPORT="$(printf '%s' "$HOSTPORT" | xargs)"

          HOST="$HOSTPORT"
          PORT="${FTP_PORT_RAW:-21}"

          # If host looks like host:port (not IPv6), split it.
          if [[ "$HOSTPORT" == *:* && "$HOSTPORT" != \[*\] ]]; then
            CAND_PORT="${HOSTPORT##*:}"
            CAND_HOST="${HOSTPORT%%:*}"
            if [[ "$CAND_PORT" =~ ^[0-9]+$ ]]; then
              HOST="$CAND_HOST"
              # Only take port from FTP_SERVER when FTP_PORT wasn't provided.
              if [ -z "${FTP_PORT_RAW:-}" ]; then
                PORT="$CAND_PORT"
              fi
            fi
          fi

          if [ -z "$HOST" ]; then
            echo "ok=false" >> "$GITHUB_OUTPUT"
            echo "Unable to parse FTP host from FTP_SERVER secret." >&2
            exit 0
          fi

          echo "ok=true" >> "$GITHUB_OUTPUT"
          echo "host=$HOST" >> "$GITHUB_OUTPUT"
          echo "port=$PORT" >> "$GITHUB_OUTPUT"

          if [ "$HAS_PROTO" = true ]; then
            echo "Note: FTP_SERVER appears to include a protocol (e.g., ftps://). Use hostname only (e.g., ftp.kubus.site)."
          fi

      - name: Set up Flutter
        if: ${{ steps.ftp.outputs.ok == 'true' }}
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      - name: Prepare Dart defines (optional)
        id: defines
        if: ${{ steps.ftp.outputs.ok == 'true' }}
        shell: bash
        env:
          KUBUS_BACKEND_URL: ${{ secrets.KUBUS_BACKEND_URL }}
          KUBUS_WALLETCONNECT_PROJECT_ID: ${{ secrets.KUBUS_WALLETCONNECT_PROJECT_ID }}
          KUBUS_PINATA_API_KEY: ${{ secrets.KUBUS_PINATA_API_KEY }}
          KUBUS_PINATA_SECRET_KEY: ${{ secrets.KUBUS_PINATA_SECRET_KEY }}
        run: |
          ARGS=""
          add() {
            local name="$1"
            local value="$2"
            if [ -n "$value" ]; then
              ARGS="$ARGS --dart-define=${name}=${value}"
            fi
          }
          add KUBUS_BACKEND_URL "$KUBUS_BACKEND_URL"
          add KUBUS_WALLETCONNECT_PROJECT_ID "$KUBUS_WALLETCONNECT_PROJECT_ID"
          add KUBUS_PINATA_API_KEY "$KUBUS_PINATA_API_KEY"
          add KUBUS_PINATA_SECRET_KEY "$KUBUS_PINATA_SECRET_KEY"
          echo "args=$ARGS" >> "$GITHUB_OUTPUT"

      - name: Build Flutter web
        if: ${{ steps.ftp.outputs.ok == 'true' }}
        run: |
          flutter pub get
          flutter build web --release ${{ steps.defines.outputs.args }}

      - name: Show runner public IP (for cPanel allowlist)
        if: ${{ steps.ftp.outputs.ok == 'true' }}
        shell: bash
        run: |
          echo "Runner public egress IP (best-effort):"

          echo -n "ipify: "
          curl -fsS https://api.ipify.org || true
          echo

          echo -n "ifconfig.me: "
          curl -fsS https://ifconfig.me || true
          echo

          if command -v dig >/dev/null 2>&1; then
            echo -n "opendns: "
            dig +short myip.opendns.com @resolver1.opendns.com || true
            echo
          else
            echo "dig not available on runner"
          fi

      - name: Preflight FTP connectivity
        if: ${{ steps.ftp.outputs.ok == 'true' && steps.ftp_target.outputs.ok == 'true' }}
        id: net
        shell: bash
        env:
          FTP_HOST: ${{ steps.ftp_target.outputs.host }}
          FTP_PORT: ${{ steps.ftp_target.outputs.port }}
        run: |
          PORT="${FTP_PORT:-21}"
          echo "Checking TCP connectivity to ${FTP_HOST}:${PORT}..."

          if ! getent hosts "$FTP_HOST" >/dev/null 2>&1; then
            echo "DNS lookup failed for the configured FTP host." >&2
            echo "Check your Actions secret FTP_SERVER. It must be a resolvable hostname like: ftp.kubus.site" >&2
            echo "Do NOT include protocol (ftp://, ftps://), paths (/...), or surrounding spaces." >&2
            echo "ok=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          # nc is available on ubuntu-latest
          if nc -vz -w 10 "$FTP_HOST" "$PORT"; then
            echo "FTP port reachable."
            echo "ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "Unable to reach ${FTP_HOST}:${PORT} from this runner."
            echo "If your host requires allowlisting GitHub Actions runner IPs, add them in your hosting firewall." 
            echo "If your host only supports SFTP, FTP deploy won't work; switch to an SFTP-based deploy." 
            echo "ok=false" >> "$GITHUB_OUTPUT"
          fi

      - name: FTP Deploy (Flutter Web)
        if: ${{ steps.ftp.outputs.ok == 'true' && steps.ftp_target.outputs.ok == 'true' && steps.net.outputs.ok == 'true' }}
        uses: SamKirkland/FTP-Deploy-Action@v4.3.6
        with:
          server: ${{ steps.ftp_target.outputs.host }}
          username: ${{ secrets.FTP_USERNAME }}
          password: ${{ secrets.FTP_PASSWORD }}
          protocol: ${{ vars.FTP_PROTOCOL || 'ftps' }}
          port: ${{ steps.ftp_target.outputs.port }}
          security: ${{ vars.FTP_SECURITY || 'loose' }}
          timeout: ${{ vars.FTP_TIMEOUT_MS || 120000 }}
          local-dir: build/web/
          server-dir: /app.kubus.site/

      - name: Skip deploy (invalid FTP_SERVER)
        if: ${{ steps.ftp.outputs.ok == 'true' && steps.ftp_target.outputs.ok != 'true' }}
        run: |
          echo "FTP secrets are present, but FTP_SERVER could not be parsed into a hostname."
          echo "Set FTP_SERVER to something like: ftp.kubus.site (no ftps://, no path, no spaces)."

      - name: Skip deploy (FTP not reachable)
        if: ${{ steps.ftp.outputs.ok == 'true' && steps.net.outputs.ok != 'true' }}
        run: |
          echo "FTP server is not reachable from this GitHub runner; skipping web deploy to avoid a failed workflow."

      - name: Skip deploy (missing FTP secrets)
        if: ${{ steps.ftp.outputs.ok != 'true' }}
        run: |
          echo "FTP secrets not configured; skipping web deploy."

  apk:
    name: Build APK + upload to GitHub Release
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.build_apk) }}
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: false

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Accept Android licenses
        shell: bash
        run: |
          # On GitHub Actions, bash runs with -e -o pipefail by default.
          # When sdkmanager finishes, `yes` can hit a broken pipe (exit 141) which
          # would fail the step even though licenses were accepted.
          # We capture sdkmanager's exit code and ignore the `yes` exit code.
          set +e
          set +o pipefail
          yes | sdkmanager --licenses > /dev/null
          SDK_STATUS=${PIPESTATUS[1]}
          set -o pipefail
          set -e

          if [ "$SDK_STATUS" -ne 0 ]; then
            exit "$SDK_STATUS"
          fi

      - name: Install Android SDK components
        shell: bash
        run: |
          sdkmanager --install "cmdline-tools;latest" "platforms;android-36" "build-tools;36.0.0" "platform-tools"

      - name: Flutter pub get
        run: flutter pub get

      - name: Prepare Dart defines (optional)
        id: apk_defines
        shell: bash
        env:
          KUBUS_BACKEND_URL: ${{ secrets.KUBUS_BACKEND_URL }}
          KUBUS_WALLETCONNECT_PROJECT_ID: ${{ secrets.KUBUS_WALLETCONNECT_PROJECT_ID }}
          KUBUS_PINATA_API_KEY: ${{ secrets.KUBUS_PINATA_API_KEY }}
          KUBUS_PINATA_SECRET_KEY: ${{ secrets.KUBUS_PINATA_SECRET_KEY }}
        run: |
          ARGS=""
          add() {
            local name="$1"
            local value="$2"
            if [ -n "$value" ]; then
              ARGS="$ARGS --dart-define=${name}=${value}"
            fi
          }
          add KUBUS_BACKEND_URL "$KUBUS_BACKEND_URL"
          add KUBUS_WALLETCONNECT_PROJECT_ID "$KUBUS_WALLETCONNECT_PROJECT_ID"
          add KUBUS_PINATA_API_KEY "$KUBUS_PINATA_API_KEY"
          add KUBUS_PINATA_SECRET_KEY "$KUBUS_PINATA_SECRET_KEY"
          echo "args=$ARGS" >> "$GITHUB_OUTPUT"

      - name: Build APK (release mode, current project signing)
        run: flutter build apk --release ${{ steps.apk_defines.outputs.args }}

      - name: Compute release metadata
        id: meta
        shell: bash
        run: |
          VERSION=$(grep -E '^version:\s*' pubspec.yaml | awk '{print $2}' | cut -d+ -f1)
          if [ -z "$VERSION" ]; then
            echo "Unable to parse version from pubspec.yaml" >&2
            exit 1
          fi

          TAG="v${VERSION}-alpha"

          # Allow manual override when workflow_dispatch provides a tag.
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.release_tag }}" ]; then
            TAG="${{ inputs.release_tag }}"
          fi

          # File name requested by user: art.kubus.vX.Y.Z.-alpha.apk
          APK_NAME="art.kubus.v${VERSION}.-alpha.apk"

          # prerelease: always true on push; configurable on manual.
          PRE="true"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PRE="${{ inputs.prerelease }}"
          fi

          # publish: always on push; configurable on manual.
          PUB="true"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PUB="${{ inputs.publish_github_release }}"
          fi

          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "apk_name=${APK_NAME}" >> "$GITHUB_OUTPUT"
          echo "prerelease=${PRE}" >> "$GITHUB_OUTPUT"
          echo "publish=${PUB}" >> "$GITHUB_OUTPUT"

      - name: Rename APK asset
        id: rename
        shell: bash
        run: |
          SRC="build/app/outputs/flutter-apk/app-release.apk"
          if [ ! -f "$SRC" ]; then
            echo "Expected APK not found at $SRC" >&2
            ls -la build/app/outputs/flutter-apk || true
            exit 1
          fi
          DEST="build/app/outputs/flutter-apk/${{ steps.meta.outputs.apk_name }}"
          cp "$SRC" "$DEST"
          echo "dest=$DEST" >> "$GITHUB_OUTPUT"

      - name: Upload APK as workflow artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.meta.outputs.apk_name }}
          path: ${{ steps.rename.outputs.dest }}
          if-no-files-found: error

      - name: Create/Update GitHub Release + upload APK
        if: ${{ steps.meta.outputs.publish == 'true' }}
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.meta.outputs.tag }}
          name: art.kubus v${{ steps.meta.outputs.version }} alpha
          prerelease: ${{ steps.meta.outputs.prerelease }}
          generateReleaseNotes: true
          allowUpdates: true
          replacesArtifacts: true
          artifacts: ${{ steps.rename.outputs.dest }}
